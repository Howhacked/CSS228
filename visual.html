<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Queue Virtualisation (Double Linked List Implementation)</title>
  <style>
    body {
      font-family: sans-serif;
      background-color: #f3f3f3;
      text-align: center;
      padding: 20px;
    }

    canvas {
      background: white;
      border: 1px solid #ccc;
      margin-top: 20px;
    }

    #controls {
      margin-bottom: 20px;
    }

    input {
      padding: 5px;
      width: 80px;
      margin-right: 10px;
    }

    button {
      padding: 6px 10px;
    }

    #messages {
      margin-top: 20px;
      font-size: 16px;
      font-weight: bold;
    }
  </style>
</head>
<body>

<h1>Queue Virtualisation (Double Linked List Implementation)</h1>

<div id="controls">
  <input type="text" id="valueInput" placeholder="Value">
  <button onclick="enqueue()">Enqueue</button>
  <button onclick="dequeue()">Dequeue</button>
  <button onclick="clearQueue()">Clear</button>
</div>

<div id="messages">
  <p id="actionText"></p>
</div>

<canvas id="queueCanvas" width="1200" height="400"></canvas>

<script>
  const canvas = document.getElementById("queueCanvas");
  const ctx = canvas.getContext("2d");

  const nodeWidth = 60;
  const nodeHeight = 40;
  const spacing = 30;
  const rowHeight = 100;
  const maxPerRow = 12;

  let queue = [];
  const actionText = document.getElementById("actionText");

  class VisualNode {
    constructor(value, targetX, targetY) {
      this.value = value;
      this.x = 0;
      this.y = 0;
      this.targetX = targetX;
      this.targetY = targetY;
      this.speed = 10;
    }

    updatePosition() {
      this.x += (this.targetX - this.x) / this.speed;
      this.y += (this.targetY - this.y) / this.speed;
    }

    isNearTarget() {
      return Math.abs(this.x - this.targetX) < 1 && Math.abs(this.y - this.targetY) < 1;
    }
  }

  function getCoordinates(index) {
    const row = Math.floor(index / maxPerRow);
    const col = index % maxPerRow;
    const x = 50 + col * (nodeWidth + spacing);
    const y = 80 + row * rowHeight;
    return { x, y };
  }

  function drawArrow(fromX, fromY, toX, toY, reverse = false, color = "#000") {
    const headLength = 10;
    const angle = Math.atan2(toY - fromY, toX - fromX);
    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.strokeStyle = color;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(toX, toY);
    ctx.lineTo(
      toX - headLength * Math.cos(angle - Math.PI / 6),
      toY - headLength * Math.sin(angle - Math.PI / 6)
    );
    ctx.lineTo(
      toX - headLength * Math.cos(angle + Math.PI / 6),
      toY - headLength * Math.sin(angle + Math.PI / 6)
    );
    ctx.lineTo(toX, toY);
    ctx.fillStyle = color;
    ctx.fill();
  }

  function drawQueue() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    queue.forEach((node, index) => {
      node.updatePosition();

      ctx.fillStyle = "#4CAF50";
      ctx.fillRect(node.x, node.y, nodeWidth, nodeHeight);
      ctx.strokeRect(node.x, node.y, nodeWidth, nodeHeight);

      ctx.fillStyle = "#fff";
      ctx.font = "16px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(node.value, node.x + nodeWidth / 2, node.y + nodeHeight / 2);

      if (index < queue.length - 1) {
        const next = queue[index + 1];
        drawArrow(
          node.x + nodeWidth,
          node.y + nodeHeight / 2,
          next.x,
          next.y + nodeHeight / 2
        );
        drawArrow(
          next.x,
          next.y + nodeHeight / 2 + 10,
          node.x + nodeWidth,
          node.y + nodeHeight / 2 + 10,
          true,
          "#f00"
        );
      }
    });

    // Draw Head and Tail
    if (queue.length > 0) {
      const head = queue[0];
      const tail = queue[queue.length - 1];

      ctx.fillStyle = "#000";
      ctx.font = "16px Arial";
      ctx.fillText("Head", head.x + nodeWidth / 2, head.y - 30);
      drawArrow(head.x + nodeWidth / 2, head.y - 25, head.x + nodeWidth / 2, head.y, false, "#007BFF");

      ctx.fillText("Tail", tail.x + nodeWidth / 2, tail.y + nodeHeight + 30);
      drawArrow(tail.x + nodeWidth / 2, tail.y + nodeHeight + 25, tail.x + nodeWidth / 2, tail.y + nodeHeight, false, "#FF8800");
    }

    // Continue animating if nodes are still moving
    let animating = queue.some(node => !node.isNearTarget());
    if (animating) {
      requestAnimationFrame(drawQueue);
    }
  }

  function enqueue() {
    const input = document.getElementById("valueInput");
    const value = input.value.trim();
    if (value === "") return alert("Enter a value");
    const index = queue.length;
    const { x, y } = getCoordinates(index);
    const newNode = new VisualNode(value, x, y);
    queue.push(newNode);
    input.value = "";

    actionText.textContent = `Enqueued Value: ${value}`;
    drawQueue();
  }

  function dequeue() {
    if (queue.length === 0) return alert("Queue is empty!");
    const removed = queue.shift();
    queue.forEach((node, index) => {
      const { x, y } = getCoordinates(index);
      node.targetX = x;
      node.targetY = y;
    });

    actionText.textContent = `Dequeued Value: ${removed.value}`;
    drawQueue();
  }

  function clearQueue() {
    queue = [];
    actionText.textContent = "Queue cleared.";
    drawQueue();
  }

  drawQueue();
</script>

</body>
</html>
